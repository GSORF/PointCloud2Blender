#include "importworker.h"

ImportWorker::ImportWorker(Panorama3D *panorama, GLWidget *glWidget, QString fileName, bool analyze, QObject *parent) :
    QObject(parent)
{
    //Take the filename and determine the filetype (in the beginning just .xyz)

    this->panorama = panorama;
    this->glWidget = glWidget;
    this->fileName = fileName;
    if(this->fileName.endsWith(".xyz"))
    {
        this->fileType = XYZ_ASCII;
    }
    else if(this->fileName.endsWith(".xyb"))
    {
        this->fileType = XYZ_BINARY;
    }
    else if(this->fileName.endsWith(".ply"))
    {
        this->fileType = PLY;
    }
    this->analyze = analyze;

    this->updateTimer.setInterval(10000);
    this->updateTimer.start();
    connect(&this->updateTimer, SIGNAL(timeout()), this->panorama, SLOT(refreshTextureMapsGUI()));

    this->setAutoDelete(false);

}

ImportWorker::~ImportWorker()
{

}

void ImportWorker::run()
{
    qDebug() << "Thread " << QThread::currentThread() << " is running";

    switch(this->fileType)
    {
    default:
    case XYZ_ASCII:
        import_XYZ_Ascii_File();
    break;
    case XYZ_BINARY:
        import_XYZ_Binary_File();
    break;
    case PLY:
        import_PLY_File();
    break;
    }

    this->updateTimer.stop();
    this->deleteLater();
}

void ImportWorker::import_XYZ_Ascii_File()
{
    //import the filename
    qDebug() << "opening file: " << this->fileName;

    QFile file(this->fileName);
    if(!file.open(QIODevice::ReadOnly | QIODevice::Text))
        return;

    qint64 totalSize = file.size();
    qint64 currentSize = 0;
    quint16 percent = 0;

    QTextStream inputStream(&file);
    QString line = inputStream.readLine();

    bool importerInfo = false;

    while(!line.isNull())
    {
        currentSize += line.size();

        percent = (currentSize*100.0f)/totalSize;

        Point3D _newPoint;

        //Process the line
        QStringList lineparts = line.split(" ");

        if(lineparts.count() == 6)
        {
            //Probably Normal Faro Scene Export
            _newPoint.x = lineparts[0].toFloat();
            _newPoint.y = lineparts[1].toFloat();
            _newPoint.z = lineparts[2].toFloat();
            _newPoint.r = lineparts[3].toInt();
            _newPoint.g = lineparts[4].toInt();
            _newPoint.b = lineparts[5].toInt();
        }
        else if(lineparts.count() == 8 )
        {
            //Probably Faro Scene LT Export
            if(!importerInfo)
            {
                importerInfo = true;
                emit showInfoMessage("The imported file was probably generated by Faro Scene LT!");
            }
            _newPoint.x = lineparts[2].toFloat();
            _newPoint.y = lineparts[3].toFloat();
            _newPoint.z = lineparts[4].toFloat();
            _newPoint.r = lineparts[5].toInt();
            _newPoint.g = lineparts[6].toInt();
            _newPoint.b = lineparts[7].toInt();
        }


        //send the current point over to the panorama data container
        panorama->addPoint( _newPoint );
        glWidget->addPoint( _newPoint, panorama->getTranslationVector() );
        emit importStatus(percent);


        //read the next line
        line = inputStream.readLine();
    }

    file.close();

    //after importing send a finished signal
    emit importStatus(100);
}

void ImportWorker::import_XYZ_Binary_File()
{
    //TODO
    bool importerInfo = false;

    if(!importerInfo)
    {
        importerInfo = true;
        emit showErrorMessage("The imported .xyz file has binary format. This is not supported, yet!");
    }
}

void ImportWorker::import_PLY_File()
{
    //import the filename
    qDebug() << "opening file: " << this->fileName;

    QFile file(this->fileName);
    if(!file.open(QIODevice::ReadOnly | QIODevice::Text))
        return;

    qint64 totalSize = file.size();
    qint64 currentSize = 0;
    quint16 percent = 0;

    QTextStream inputStream(&file);
    QString line = inputStream.readLine();

    bool importerInfo = false;

    int maxVertices = 0;
    int currentVertex = 0;

    bool header = true;
    bool binary = false;

    bool property_x = false;
    bool property_y = false;
    bool property_z = false;
    bool property_red = false;
    bool property_green = false;
    bool property_blue = false;
    bool property_alpha = false;

    /*
    PLY Header definitions:

    ply
    format ascii 1.0
    format binary_little_endian 1.0
    format binary_big_endian 1.0
    element vertex 12
    property float x
    property float y
    property float z
    property uchar red
    property uchar green
    property uchar blue
    property uchar alpha
    end_header

    */
    while(!line.isNull())
    {
        currentSize += line.size();


        Point3D _newPoint;

        //Process the line
        QStringList lineparts = line.split(" ");

        if(header)
        {
            percent = (currentSize*100.0f)/totalSize;

            //Parse the header information
            if(line.startsWith("format binary"))
            {
                binary = true;
                qDebug() << "PLY: HEADER binary";
            }
            if(line.startsWith("element vertex"))
            {
                maxVertices = lineparts.at(2).toInt();
                qDebug() << "PLY: HEADER maxVertices = " << maxVertices;
            }
            if(line.startsWith("property"))
            {
                if(lineparts.at(2) == "x")
                {
                    property_x = true;
                    qDebug() << "PLY: HEADER property = x";
                }
                if(lineparts.at(2) == "y")
                {
                    property_y = true;
                    qDebug() << "PLY: HEADER property = y";
                }
                if(lineparts.at(2) == "z")
                {
                    property_z = true;
                    qDebug() << "PLY: HEADER property = z";
                }
                if(lineparts.at(2) == "red")
                {
                    property_red = true;
                    qDebug() << "PLY: HEADER property = red";
                }
                if(lineparts.at(2) == "green")
                {
                    property_green = true;
                    qDebug() << "PLY: HEADER property = green";
                }
                if(lineparts.at(2) == "blue")
                {
                    property_blue = true;
                    qDebug() << "PLY: HEADER property = blue";
                }
                if(lineparts.at(2) == "alpha")
                {
                    property_alpha = true;
                    qDebug() << "PLY: HEADER property = alpha";
                }
            }


            if(line.startsWith("end_header"))
            {
                header = false;
            }
        }
        else
        {
            //Parse the mesh data
            if(binary)
            {
                //Binary
                if(!importerInfo)
                {
                    importerInfo = true;
                    emit showErrorMessage("The imported .ply file has binary format. This is not supported, yet!");
                }
                break;
            }
            else
            {
                //Ascii
                if(currentVertex < maxVertices)
                {
                    percent = (currentVertex*100.0f)/maxVertices;

                    if(lineparts.size() >= 3)
                    {
                        if(property_x)
                            _newPoint.x = lineparts.at(0).toFloat();
                        else
                            _newPoint.x = 0;
                        if(property_y)
                            _newPoint.y = lineparts.at(1).toFloat();
                        else
                            _newPoint.y = 0;
                        if(property_z)
                            _newPoint.z = lineparts.at(2).toFloat();
                        else
                            _newPoint.z = 0;
                        if(property_red)
                            _newPoint.r = lineparts.at(3).toFloat();
                        else
                            _newPoint.r = 0;
                        if(property_green)
                            _newPoint.g = lineparts.at(4).toFloat();
                        else
                            _newPoint.g = 0;
                        if(property_blue)
                            _newPoint.b = lineparts.at(5).toFloat();
                        else
                            _newPoint.b = 0;
                        if(property_alpha)
                        {
                            //TODO: implement alpha value?
                        }

                        currentVertex++;

                        //send the current point over to the panorama data container and 3D viewer:
                        panorama->addPoint( _newPoint );
                        glWidget->addPoint( _newPoint, panorama->getTranslationVector() );


                    }

                }
                else
                {
                    break;
                }
            }
        }

        emit importStatus(percent);


        //read the next line
        line = inputStream.readLine();
    }

    file.close();

    //after importing send a finished signal
    emit importStatus(100);
}
