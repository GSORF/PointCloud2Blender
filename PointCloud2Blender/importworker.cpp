/*
    PointCloud2Blender - convert point cloud files to a textured 3D mesh
    Copyright (C) 2015 Adam Kalisz (Bachelor@Kalisz.co)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "importworker.h"

ImportWorker::ImportWorker(Panorama3D *panorama, GLWidget *glWidget, QString fileName, bool analyze, QObject *parent) :
    QObject(parent)
{
    //Take the filename and determine the filetype (in the beginning just .xyz)

    this->panorama = panorama;
    this->glWidget = glWidget;
    this->fileName = fileName;
    if(this->fileName.endsWith(".xyz"))
    {
        this->fileType = XYZ_ASCII;
    }
    else if(this->fileName.endsWith(".xyb"))
    {
        this->fileType = XYZ_BINARY;
    }
    else if(this->fileName.endsWith(".ply"))
    {
        this->fileType = PLY;
    }
    this->analyze = analyze;

    this->updateTimer.setInterval(10000);

    if(analyze)
    {
        //angle accuracy must be <= than (360/maxHorizontalScannerResolution/4)

        angle_accuracy = 360.0f/30000.0f/4.0f;
        int n = qCeil(360.0f / angle_accuracy);

        histogram_horizontal_angles.resize(n);
        histogram_horizontal_angles.fill(0);

    }
    else
    {
        this->updateTimer.start();
        connect(&this->updateTimer, SIGNAL(timeout()), this->panorama, SLOT(refreshTextureMapsGUI()));
    }

    this->cancelThread = false;

    this->setAutoDelete(false);

}

ImportWorker::~ImportWorker()
{
    this->updateTimer.stop();
}

void ImportWorker::run()
{
    qDebug() << "Thread " << QThread::currentThread() << " is running";

    switch(this->fileType)
    {
    default:
    case XYZ_ASCII:
        import_XYZ_Ascii_File();
    break;
    case XYZ_BINARY:
        import_XYZ_Binary_File();
    break;
    case PLY:
        import_PLY_File();
    break;
    }

    if(analyze && !this->cancelThread)
    {
        //Count histogram values
        int resolution = 0;
        for(int i = 0; i < histogram_horizontal_angles.size(); i++)
        {
            if(histogram_horizontal_angles.at(i) != 0)
            {
                resolution++;
            }
        }

        emit originalResolution(resolution);
    }
    else
    {
        this->updateTimer.stop();
    }


    this->deleteLater();
}

void ImportWorker::import_XYZ_Ascii_File()
{
    //import the filename
    qDebug() << "opening file: " << this->fileName;

    QFile file(this->fileName);
    if(!file.open(QIODevice::ReadOnly | QIODevice::Text))
        return;

    qint64 totalSize = file.size();
    qint64 currentSize = 0;
    float percent = 0.0f;

    QTextStream inputStream(&file);
    QString line = inputStream.readLine();

    bool importerInfo = false;

    while(!line.isNull() && !this->cancelThread)
    {
        currentSize += line.size();

        percent = (currentSize*100.0f)/totalSize;

        Point3D _newPoint;

        //Process the line
        QStringList lineparts = line.split(" ");

        if(lineparts.count() >= 3 && lineparts.count() < 6)
        {
            //Read only XYZ-Parts
            _newPoint.x = lineparts[0].toFloat();
            _newPoint.y = lineparts[1].toFloat();
            _newPoint.z = lineparts[2].toFloat();
            _newPoint.r = 128;
            _newPoint.g = 128;
            _newPoint.b = 128;
        }
        else if(lineparts.count() == 6)
        {
            //Probably Normal Faro Scene Export
            _newPoint.x = lineparts[0].toFloat();
            _newPoint.y = lineparts[1].toFloat();
            _newPoint.z = lineparts[2].toFloat();
            _newPoint.r = lineparts[3].toInt();
            _newPoint.g = lineparts[4].toInt();
            _newPoint.b = lineparts[5].toInt();
        }
        else if(lineparts.count() == 8 )
        {
            //Probably Faro Scene LT Export
            if(!importerInfo)
            {
                importerInfo = true;
                emit showInfoMessage("The imported file was probably generated by Faro Scene LT!");
            }
            _newPoint.x = lineparts[2].toFloat();
            _newPoint.y = lineparts[3].toFloat();
            _newPoint.z = lineparts[4].toFloat();
            _newPoint.r = lineparts[5].toInt();
            _newPoint.g = lineparts[6].toInt();
            _newPoint.b = lineparts[7].toInt();
        }
        else if(lineparts.count() == 9 )
        {
            //Probably Agisoft Photoscan
            _newPoint.x = lineparts[2].toFloat();
            _newPoint.y = lineparts[3].toFloat();
            _newPoint.z = lineparts[4].toFloat();
            _newPoint.r = lineparts[5].toInt();
            _newPoint.g = lineparts[6].toInt();
            _newPoint.b = lineparts[7].toInt();
        }


        if(analyze)
        {
            if(determineOriginalResolution( _newPoint )) break;
        }
        else
        {
            //send the current point over to the panorama data container
            panorama->addPoint( _newPoint );
            glWidget->addPoint( _newPoint, panorama->getTranslationVector() );
        }

        emit importStatus(percent);


        //read the next line
        line = inputStream.readLine();
    }

    file.close();

    //after importing send a finished signal
    emit importStatus(100.0f);
}

void ImportWorker::import_XYZ_Binary_File()
{
    //TODO
    bool importerInfo = false;

    if(!importerInfo)
    {
        importerInfo = true;
        emit showErrorMessage("The imported .xyz file has binary format. This is not supported, yet!");
    }
}

void ImportWorker::import_PLY_File()
{
    //import the filename
    qDebug() << "opening file: " << this->fileName;

    QFile file(this->fileName);
    if(!file.open(QIODevice::ReadOnly | QIODevice::Text))
        return;

    qint64 totalSize = file.size();
    qint64 currentSize = 0;
    float percent = 0.0f;

    QTextStream inputStream(&file);
    QString line = inputStream.readLine();

    bool importerInfo = false;

    int maxVertices = 0;
    int currentVertex = 0;

    bool header = true;
    bool binary = false;

    bool property_x = false;
    bool property_y = false;
    bool property_z = false;
    bool property_red = false;
    bool property_green = false;
    bool property_blue = false;
    bool property_alpha = false;

    /*
    PLY Header definitions:

    ply
    format ascii 1.0
    format binary_little_endian 1.0
    format binary_big_endian 1.0
    element vertex 12
    property float x
    property float y
    property float z
    property uchar red
    property uchar green
    property uchar blue
    property uchar alpha
    end_header

    */
    while(!line.isNull() && !this->cancelThread)
    {
        currentSize += line.size();

        Point3D _newPoint;

        //Process the line
        QStringList lineparts = line.split(" ");

        if(header)
        {
            percent = (currentSize*100.0f)/totalSize;

            //Parse the header information
            if(line.startsWith("format binary"))
            {
                binary = true;
                qDebug() << "PLY: HEADER binary";
            }
            if(line.startsWith("element vertex"))
            {
                maxVertices = lineparts.at(2).toInt();
                qDebug() << "PLY: HEADER maxVertices = " << maxVertices;
            }
            if(line.startsWith("property"))
            {
                if(lineparts.at(2) == "x")
                {
                    property_x = true;
                    qDebug() << "PLY: HEADER property = x";
                }
                if(lineparts.at(2) == "y")
                {
                    property_y = true;
                    qDebug() << "PLY: HEADER property = y";
                }
                if(lineparts.at(2) == "z")
                {
                    property_z = true;
                    qDebug() << "PLY: HEADER property = z";
                }
                if(lineparts.at(2).contains("red"))
                {
                    property_red = true;
                    qDebug() << "PLY: HEADER property = red";
                }
                if(lineparts.at(2).contains("green"))
                {
                    property_green = true;
                    qDebug() << "PLY: HEADER property = green";
                }
                if(lineparts.at(2).contains("blue"))
                {
                    property_blue = true;
                    qDebug() << "PLY: HEADER property = blue";
                }
                if(lineparts.at(2).contains("alpha"))
                {
                    property_alpha = true;
                    qDebug() << "PLY: HEADER property = alpha";
                }
            }


            if(line.startsWith("end_header"))
            {
                header = false;
            }
        }
        else
        {
            //Parse the mesh data
            if(binary)
            {
                //Binary
                if(!importerInfo)
                {
                    importerInfo = true;
                    emit showErrorMessage("The imported .ply file has binary format. This is not supported, yet!");
                }
                break;
            }
            else
            {
                //Ascii
                if(currentVertex < maxVertices)
                {
                    percent = (currentVertex*100.0f)/maxVertices;

                    if(lineparts.size() >= 3)
                    {
                        if(property_x)
                            _newPoint.x = lineparts.at(0).toFloat();
                        else
                            _newPoint.x = 0;
                        if(property_y)
                            _newPoint.y = lineparts.at(1).toFloat();
                        else
                            _newPoint.y = 0;
                        if(property_z)
                            _newPoint.z = lineparts.at(2).toFloat();
                        else
                            _newPoint.z = 0;
                        if(property_red)
                            _newPoint.r = lineparts.at(3).toFloat();
                        else
                            _newPoint.r = 0;
                        if(property_green)
                            _newPoint.g = lineparts.at(4).toFloat();
                        else
                            _newPoint.g = 0;
                        if(property_blue)
                            _newPoint.b = lineparts.at(5).toFloat();
                        else
                            _newPoint.b = 0;
                        if(property_alpha)
                        {
                            //TODO: implement alpha value?
                        }

                        currentVertex++;

                        if(analyze)
                        {
                            if(determineOriginalResolution( _newPoint )) break;
                        }
                        else
                        {
                            //send the current point over to the panorama data container and 3D viewer:
                            panorama->addPoint( _newPoint );
                            glWidget->addPoint( _newPoint, panorama->getTranslationVector() );

                        }

                    }

                }
                else
                {
                    break;
                }
            }
        }

        emit importStatus(percent);


        //read the next line
        line = inputStream.readLine();
    }

    file.close();

    //after importing send a finished signal
    emit importStatus(100.0f);
}

bool ImportWorker::determineOriginalResolution(Point3D newPoint)
{
    float theta, phi, radius;

    this->panorama->convertToSpherical(newPoint, theta, phi, radius);

    /*
     * BUGFIX: floating-point imprecision leading to negative index
     */
    if(theta < angle_accuracy)
    {
        //theta = 0.0f;
    }

    float alpha = qRadiansToDegrees(theta);

    int index = 0;

    if(alpha >= angle_accuracy)
    {
        index = qFloor(alpha / angle_accuracy);
    }

    //Sanity check:
    if(index >= 0 && index < histogram_horizontal_angles.size() )
    {
        //increment histogram value depending on horizontal angle
        histogram_horizontal_angles[ index ]++;
    }

    //continue analyzing
    return false;
}

void ImportWorker::stopThread()
{
    this->cancelThread = true;
}
